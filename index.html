<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChatGPT厳選銘柄ウォッチリスト</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header class="hero">
      <p class="hero-eyebrow">AI Powered Market Insights</p>
      <h1>ChatGPT厳選銘柄ウォッチリスト</h1>
      <p class="lead">
        ChatGPTが選出した銘柄のパフォーマンスを追跡し、
        データに基づいた投資判断をサポートします。
      </p>
      <div class="cta-group">
        <a class="cta" href="#watchlist">最新のウォッチリストを見る</a>
        <a class="cta ghost" href="https://note.com/entry20210104/n/n00e96f5c1f27" target="_blank" rel="noopener noreferrer">
          メンバーシップで銘柄をチェック
        </a>
      </div>
      <div class="position-strip" aria-live="polite">
        <div class="position-strip__header">
          <span class="dot"></span>
          <span>ポジション速報</span>
        </div>
        <div class="position-strip__list" id="position-strip"></div>
      </div>
    </header>

    <main>
      <section class="highlights">
        <article>
          <h2>勝率</h2>
          <p class="metric">
            <span class="metric-value" id="metric-win-rate">--</span>
            <span class="metric-suffix">%</span>
          </p>
          <p class="description">損益率がプラスの銘柄比率</p>
        </article>
        <article>
          <h2>平均リターン</h2>
          <p class="metric">
            <span class="metric-value" id="metric-average-return">--</span>
            <span class="metric-suffix">%</span>
          </p>
          <p class="description">損益率の平均値（計測可能な銘柄）</p>
        </article>
        <article>
          <h2>監視銘柄数</h2>
          <p class="metric">
            <span class="metric-value" id="metric-active-count">--</span>
          </p>
          <p class="description">現在監視中の銘柄数</p>
        </article>
      </section>

      <section id="watchlist" class="watchlist">
        <h2>ウォッチリスト</h2>
        <p class="issue-caption">
        </p>
        <div class="table-controls">
          <label for="status-filter">
            監視ステータス
            <select id="status-filter">
              <option value="all">すべて</option>
              <option value="監視中">監視中のみ</option>
              <option value="監視終了">監視終了のみ</option>
            </select>
          </label>
          <label for="code-filter">
            銘柄コード・名称
            <input
              type="search"
              id="code-filter"
              placeholder="例: 1234 や 企業名で検索"
              autocomplete="off"
            />
          </label>
        </div>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>号数</th>
                <th>銘柄</th>
                <th>ステータス</th>
                <th>監視開始日</th>
                <th>監視開始時株価（終値）</th>
                <th>監視終了日</th>
                <th>監視終了時株価（終値／イベント）</th>
                <th>株価差</th>
                <th>値上がり率</th>
              </tr>
            </thead>
            <tbody id="issue-table-body"></tbody>
          </table>
          <p id="issue-table-message" class="table-message">創刊号の銘柄データを読み込み中です…</p>
        </div>
      </section>

      <section class="about">
        <h2>どのように銘柄を選定しているのか</h2>
        <p>
          ファンダメンタルズ分析、センチメント分析、過去の株価パターンなど、複数の視点から総合的に評価し、
          ChatGPTが推奨する銘柄を絞り込んでいます。定期的な見直しにより、常に鮮度の高いウォッチリストを提供します。
        </p>
      </section>
  </main>

  <footer>
    <small>© 2024 ChatGPT Fund Manager</small>
  </footer>
  <script>
      const state = {
        stocks: [],
        filters: {
          status: "all",
          query: "",
        },
      };

      async function loadIssueData() {
        const tableBody = document.getElementById("issue-table-body");
        const message = document.getElementById("issue-table-message");
        const statusFilter = document.getElementById("status-filter");
        const codeFilter = document.getElementById("code-filter");
        const issueCaption = document.querySelector(".issue-caption");

        try {
          const response = await fetch("data/issue-001.json", { cache: "no-store" });
          if (!response.ok) {
            throw new Error("Failed to load issue data");
          }

          const payload = await response.json();
          const stocks = Array.isArray(payload.stocks) ? payload.stocks : [];

          if (!stocks.length) {
            message.textContent = "銘柄データが未登録です。note記事へのアクセス制限により自動取得に失敗しました。";
            message.className = "table-message warning";
            return;
          }

          if (issueCaption) {
            const issueLabel = payload.issue ? `${payload.issue}の銘柄データ` : "";
            const sourceLink =
              payload.source && typeof payload.source === "string"
                ? `<a href="${payload.source}" target="_blank" rel="noopener noreferrer">出典: note</a>`
                : "";
            const membershipLink = `<a class="inline-cta" href="https://note.com/entry20210104/n/n00e96f5c1f27" target="_blank" rel="noopener noreferrer">メンバーシップで全銘柄と更新速報を見る</a>`;
            issueCaption.innerHTML = [issueLabel, sourceLink, membershipLink].filter(Boolean).join(" ｜ ");
          }

          state.stocks = stocks;
          state.filters.status = statusFilter ? statusFilter.value : "all";
          state.filters.query = codeFilter ? codeFilter.value.trim().toLowerCase() : "";

          const triggerUpdate = () => {
            updateView(tableBody, message);
          };

          if (statusFilter) {
            statusFilter.addEventListener("change", (event) => {
              state.filters.status = event.target.value;
              triggerUpdate();
            });
          }

          if (codeFilter) {
            codeFilter.addEventListener("input", (event) => {
              state.filters.query = event.target.value.trim().toLowerCase();
              triggerUpdate();
            });
          }

          updateView(tableBody, message);
        } catch (error) {
          console.error(error);
          message.textContent = "データの取得に失敗しました。ネットワーク設定をご確認ください。";
          message.className = "table-message error";
        }
      }

      function updateView(tableBody, message) {
        const filteredStocks = getFilteredStocks();
        const metrics = populateTable(tableBody, filteredStocks);
        toggleTableMessage(message, filteredStocks.length > 0);
        updateHighlights(metrics);
        updatePositionStrip(state.stocks);
      }

      function getFilteredStocks() {
        const statusFilter = state.filters.status;
        const query = state.filters.query;

        return state.stocks.filter((item) => {
          const status = typeof item.status === "string" ? item.status.trim() : "";

          if (statusFilter !== "all" && status !== statusFilter) {
            return false;
          }

          if (!query) {
            return true;
          }

          const codeText =
            item.code !== undefined && item.code !== null
              ? String(item.code).toLowerCase()
              : "";
          const nameText = typeof item.name === "string" ? item.name.toLowerCase() : "";

          return codeText.includes(query) || nameText.includes(query);
        });
      }

      function populateTable(tableBody, stocks) {
        if (!tableBody) {
          return { returns: [], activeCount: 0 };
        }

        tableBody.textContent = "";

        const fragment = document.createDocumentFragment();
        const completedReturns = [];
        let activeCount = 0;

        stocks.forEach((item) => {
          const row = document.createElement("tr");

          const priceStartValue = parsePrice(item.priceStart);
          const priceEndValue = parsePrice(item.priceEnd);
          const currentPriceValue = parsePrice(item.currentPrice);
          const comparisonValue = Number.isFinite(priceEndValue)
            ? priceEndValue
            : Number.isFinite(currentPriceValue)
            ? currentPriceValue
            : null;
          const valueChange =
            Number.isFinite(priceStartValue) && Number.isFinite(comparisonValue)
              ? comparisonValue - priceStartValue
              : null;
          const pnlValue =
            Number.isFinite(priceStartValue) &&
            Number.isFinite(comparisonValue) &&
            priceStartValue !== 0
              ? (valueChange / priceStartValue) * 100
              : null;

          const status = typeof item.status === "string" ? item.status.trim() : "";
          const priceEndForDisplay = item.priceEnd ?? item.currentPrice ?? "-";

          const cells = [
            item.issueNumber || "-",
            { type: "stock", name: item.name, code: item.code },
            status || "-",
            item.watchStart || "-",
            formatCurrency(priceStartValue, item.priceStart),
            item.watchEnd || "-",
            formatCurrency(comparisonValue, priceEndForDisplay),
            formatDifference(valueChange),
            formatPercentage(pnlValue),
          ];

          cells.forEach((value, index) => {
            const cell = document.createElement("td");
            if (index === 1 && value && typeof value === "object" && value.type === "stock") {
              const name = document.createElement("div");
              name.classList.add("stock-name");
              name.textContent = value.name || "-";

              const code = document.createElement("div");
              code.classList.add("stock-code");
              code.textContent = value.code ? `(${value.code})` : "";

              cell.appendChild(name);
              cell.appendChild(code);
            } else if (index === 2) {
              cell.classList.add("status-cell");

              const badge = document.createElement("span");
              badge.classList.add("status");

              if (value === "監視中") {
                badge.classList.add("active");
              } else if (value === "監視終了") {
                badge.classList.add("completed");
              }

              badge.textContent = value;
              cell.appendChild(badge);
            } else {
              cell.textContent = value;
            }

            if (index === 7) {
              const numeric = parsePrice(value);
              if (Number.isFinite(numeric)) {
                if (numeric > 0) {
                  cell.classList.add("positive");
                } else if (numeric < 0) {
                  cell.classList.add("negative");
                } else {
                  cell.classList.add("neutral");
                }
              }
            }

            if (index === 8) {
              const numeric = extractNumericPercentage(value);
              if (Number.isFinite(numeric)) {
                if (numeric > 0) {
                  cell.classList.add("positive");
                } else if (numeric < 0) {
                  cell.classList.add("negative");
                } else {
                  cell.classList.add("neutral");
                }
              }
            }

            row.appendChild(cell);
          });

          if (status === "監視中") {
            activeCount += 1;
          }

          if (status === "監視終了" && Number.isFinite(pnlValue)) {
            completedReturns.push(pnlValue);
          }

          fragment.appendChild(row);
        });

        tableBody.appendChild(fragment);

        return {
          returns: completedReturns,
          activeCount,
        };
      }

      function toggleTableMessage(message, hasRows) {
        if (!message) {
          return;
        }

        if (hasRows) {
          message.textContent = "";
          message.style.display = "none";
          message.className = "table-message";
        } else {
          message.textContent = "条件に一致する銘柄がありません。";
          message.style.display = "";
          message.className = "table-message";
        }
      }

      function parsePrice(value) {
        if (typeof value === "number") {
          return Number.isFinite(value) ? value : null;
        }

        if (typeof value === "string" && value.trim().length) {
          const cleaned = value.replace(/[^0-9+\-.]/g, "");
          if (!cleaned.trim()) {
            return null;
          }
          const numeric = Number(cleaned);
          return Number.isFinite(numeric) ? numeric : null;
        }

        return null;
      }

      function formatCurrency(numericValue, fallback) {
        const fallbackIsString = typeof fallback === "string";
        const hasContext =
          fallbackIsString &&
          /[^\d,.\s円+-]/.test(fallback);

        if (fallbackIsString && hasContext) {
          return fallback;
        }

        if (Number.isFinite(numericValue)) {
          return `${numericValue.toLocaleString("ja-JP")}円`;
        }

        if (fallbackIsString) {
          return fallback;
        }

        return "-";
      }

      function formatPercentage(value) {
        if (!Number.isFinite(value)) {
          return "-";
        }

        const rounded = Math.round(value * 10) / 10;
        const normalized = Object.is(rounded, -0) ? 0 : rounded;
        const sign = normalized > 0 ? "+" : normalized < 0 ? "" : "";
        return `${sign}${normalized.toFixed(1)}%`;
      }

      function formatDifference(value) {
        if (!Number.isFinite(value)) {
          return "-";
        }

        const rounded = Math.round(value);
        const sign = rounded > 0 ? "+" : rounded < 0 ? "" : "";
        const normalized = Object.is(rounded, -0) ? 0 : rounded;
        return `${sign}${normalized.toLocaleString("ja-JP")}円`;
      }

      function extractNumericPercentage(value) {
        if (typeof value === "number") {
          return value;
        }

        if (typeof value === "string") {
          const numeric = Number(value.replace(/[^0-9+\-.]/g, ""));
          return Number.isFinite(numeric) ? numeric : null;
        }

        return null;
      }

      function updateHighlights({ returns, activeCount }) {
        const winRateEl = document.getElementById("metric-win-rate");
        const avgReturnEl = document.getElementById("metric-average-return");
        const activeCountEl = document.getElementById("metric-active-count");

        const validReturns = Array.isArray(returns) ? returns.filter((value) => Number.isFinite(value)) : [];

        const winCount = validReturns.filter((value) => value > 0).length;
        const winRate = validReturns.length ? (winCount / validReturns.length) * 100 : null;
        const averageReturn = validReturns.length
          ? validReturns.reduce((sum, value) => sum + value, 0) / validReturns.length
          : null;

        if (winRateEl) {
          if (winRate !== null) {
            const rounded = Math.round(winRate * 10) / 10;
            const normalized = Object.is(rounded, -0) ? 0 : rounded;
            winRateEl.textContent = normalized.toFixed(1);
          } else {
            winRateEl.textContent = "--";
          }
        }

        if (avgReturnEl) {
          if (averageReturn !== null) {
            const rounded = Math.round(averageReturn * 10) / 10;
            const normalized = Object.is(rounded, -0) ? 0 : rounded;
            const sign = normalized > 0 ? "+" : normalized < 0 ? "" : "";
            avgReturnEl.textContent = `${sign}${normalized.toFixed(1)}`;
          } else {
            avgReturnEl.textContent = "--";
          }
        }

        if (activeCountEl) {
          activeCountEl.textContent = Number.isInteger(activeCount) ? activeCount : "--";
        }
      }

      function updatePositionStrip(stocks) {
        const strip = document.getElementById("position-strip");
        if (!strip) return;

        strip.textContent = "";

        const snapshots = (Array.isArray(stocks) ? stocks : [])
          .map((item) => buildSnapshot(item))
          .filter(Boolean)
          .sort((a, b) => {
            if (a.statusPriority !== b.statusPriority) {
              return a.statusPriority - b.statusPriority;
            }
            return b.order - a.order;
          })
          .slice(0, 4);

        snapshots.forEach((snapshot) => {
          const card = document.createElement("div");
          card.className = "position-chip";

          const name = document.createElement("div");
          name.className = "position-chip__name";
          name.textContent = snapshot.name;

          const code = document.createElement("div");
          code.className = "position-chip__code";
          code.textContent = snapshot.code;

          const status = document.createElement("span");
          status.className = "position-chip__status";
          status.textContent = snapshot.status;
          status.dataset.state = snapshot.status === "監視終了" ? "done" : "active";

          const perf = document.createElement("div");
          perf.className = "position-chip__perf";
          perf.textContent = snapshot.perf;
          perf.dataset.trend = snapshot.trend;

          const price = document.createElement("div");
          price.className = "position-chip__price";
          price.textContent = snapshot.priceLabel;

          card.appendChild(name);
          card.appendChild(code);
          card.appendChild(status);
          card.appendChild(perf);
          card.appendChild(price);

          strip.appendChild(card);
        });
      }

      function buildSnapshot(item) {
        const priceStart = parsePrice(item.priceStart);
        const priceEnd = parsePrice(item.priceEnd);
        const currentPrice = parsePrice(item.currentPrice);
        const comparison = Number.isFinite(priceEnd)
          ? priceEnd
          : Number.isFinite(currentPrice)
          ? currentPrice
          : null;
        const diff = Number.isFinite(priceStart) && Number.isFinite(comparison) ? comparison - priceStart : null;
        const pct = Number.isFinite(priceStart) && Number.isFinite(comparison) && priceStart !== 0 ? (diff / priceStart) * 100 : null;

        const status = typeof item.status === "string" ? item.status.trim() : "-";
        const trend = Number.isFinite(pct) ? (pct > 0 ? "up" : pct < 0 ? "down" : "flat") : "none";

        return {
          name: item.name || "-",
          code: item.code ? `(${item.code})` : "",
          status,
          perf: Number.isFinite(pct) ? `${pct > 0 ? "+" : ""}${(Math.round(pct * 10) / 10).toFixed(1)}%` : "--",
          priceLabel:
            Number.isFinite(comparison) && Number.isFinite(priceStart)
              ? `${formatCurrency(comparison, item.priceEnd ?? item.currentPrice)} / ${formatCurrency(priceStart, item.priceStart)}`
              : formatCurrency(comparison, item.priceEnd ?? item.currentPrice) || "--",
          trend,
          statusPriority: status === "監視中" ? 0 : 1,
          order: parseDateValue(item.watchStart),
        };
      }

      function parseDateValue(dateText) {
        if (typeof dateText !== "string") return 0;
        const normalized = dateText.replace(/[年月]/g, "/").replace(/日/g, "");
        const time = Date.parse(normalized);
        return Number.isFinite(time) ? time : 0;
      }

      loadIssueData();
    </script>
  </body>
</html>
